# 正则表达式入门

[TOC]

## 1. 用途说明

任何一个工具在读入一个文件时, 总是需要按照特定的语法规则理解输入文件的内容, 理解的前提是工具将输入文件按照语法规则拆分成特定的小块。拆分的过程称为令牌化(tokenize), 工具中执行拆分的模块叫做解析器(parser), 解析器参考的语法规则被称为正则文法(regular syntax), 描述正则文法的表达式被称为正则表达式(regular expression), 简称为regex.

> 例如vcs读入verilog文件时, 会首先按照verilog的语法将语句"assign sum = a + b;"拆分成"assign", "sum", "+", "a", "b", ";"几个部分

由于几乎所有工具都需要做文本解析, 区别只是解析的内容和粒度不同, 因此几乎所有编程语言都提供了正则表达式相关的库, 开发者可以用这些库开发自己的工具

> 例如perl内置正则表达式语法, python标准库中有re模块, tcl标准库中有regexp模块等

除了编程语言之外, 很多工具也提供了正则表达式用来提高搜索精度, 例如grep, sed, vim, 几乎所有的现代编辑器都支持正则表达式。

因此, 对于IC从业人员来说, 正则表达式一般用在两个地方

- 开发各类工具和脚本, 脚本越复杂, 需要用的正则表达式就越复杂
- 使用grep, vim等进行精确搜索, 或执行批量替换操作

大部分同事不需要自己写脚本或者做flow, 因此只需要学习一些基本的正则表达式在搜索或者替换时可以提高效率即可

## 2. 基本语法

正则表达式的语法有两个基本流派, 早期的ed流派和现代的perl流派

- ed是unix上一个编辑器的名字, 后来衍生发展出了sed, vi, vim等工具, grep的语法也是这个流派
- perl是正则表达式的集大成者, python的re库也是参照perl的语法设计的

两者只在某些语法细节上有一点不同, 由于这些语法细节容易给大家造成混淆, 而grep, sed, vim大家用的比较多, 因此下面只讲ed流派语法中最常用的几个语法.

### 2.1 元字符

元字符是正则表达式的基本单元

- 基本字符：就是字面意义上的一个字符
  - `a` 表示a
  - `,` 表示逗号
- 类型字符: 类型字符用一个标记来指代一类字符
  - `.`  表示任一字符
  - `\w` 表示字母或数字或下划线(word)
  - `\d` 表示数字0到9(digit), 有些工具不支持\d, 比如sed, 这时要用[0-9]替代
  - `\s` 表示空格或tab(space)
  - `\W` 表示不是字母不是数字也不是下划线
  - `\D` 表示不是数字
  - `\S` 表示不是空格
- 字符选择：字符选择用来精细化地控制字符选择范围
  - `[]` 中括号表示元字符的选择
    - `-`  中括号中的连字符表示元字符的选择范围
    - `^`  中括号开头的尖号表示取反
    > 例如[ab]表示a或者b, [a-z_0-9]表示a到z的字母, 或者下划线, 或者0-9, [^abcd]表示除了abcd之外的任意字符

### 2.2 量词与多个字符

量词是跟在元字符后面, 用来表示元字符数量的语法

一个元字符如果没有跟量词, 那么表示这个元字符出现一次

常用的量词有三个

- `*`  表示0到多个
- `\+` 表示1到多个
- `\?` 表示0个或1个

> 量词有贪婪量词和非贪婪量词之分, 这三个量词全是贪婪量词, 引擎认为此时应该匹配的越多越好
> 用`a\+b`去匹配`aaaabbbb`时，匹配到的是`aaaabbbb`,而不是`aaaab`
> 而用非贪婪量词去匹配时，匹配到的是`aaaab`
> 贪婪量词和非贪婪量词的区别会对很多刚入门的人造成困扰, 匹配不到又不知道错在哪，一般就是错在该使用非贪婪量词时使用了入门时学的贪婪量词

#### 2.2.1 例子：verilog的信号名

verilog中的信号名必须以字符或者下划线开头, 不允许以数字开头, 信号名的长度大于等于1, 表示为

`[a-zA-Z_]\w*`

其中出现了两个元字符, `[a-zA-Z_]`和`\w`
以及一个用来修饰`\w`的量词`*`, 量词`*`的存在保证了信号名长度最小为1, 也就是`[a-zA-Z_]`

错误的正则表达式

- `\w*`, 会使得空字符串也变成信号名, 也就是信号名长度变成了0
- `\w\+`, 会使得`9abc`也被识别成信号名, 不够准确, 但有时候为了简化正则表达式的长度, 也会这么写
- `[a-zA-Z_]\w\+`, 会使得信号名长度最小值变成了2, 单字符的信号名`d`或者`q`无法被识别到

### 2.3 分组与选择

如果元字符是原子, 那么分组就是分子, 将多个元字符组装起来, 作为一个整体用作模式匹配. 分组常被用于复杂的模式搜索或模式替换

- `\(\)` 将一串元字符或者量词包起来作为一个整体
- `\|`   正则表达式的或操作, 表示选择其中之一

> 例如`\(reg\|wire\|logic\)`表示匹配reg或wire或logic

量词也可以用来修饰分组, 例如`\(reg\|wire\|logic\)\s\+\(\[\d\+:0\]\)\?\s\+\w\+;`能够匹配到一个verilog里的信号声明语句
量词`\?`在这个表达式里用来修饰`\(\[\d\+:0\]\)`，因为位宽部分是可选的, 可能存在也可能不存在

#### 2.3.1 例子：匹配"localparam 参数名 = 数字;"

verilog的数字有几种写法

`[1-9]\d*` 十进制数
`[1-9]\d*'h[0-9a-fA-F_]\+` 十六进制数
`[1-9]\d*'d[0-9_]\+` 十进制数
`[1-9]\d*'b[01_]\+` 二进制数

有时为了简化, 就直接写成了
`\d\+` 十进制数
`\d\+'h[0-9a-fA-F_]\+` 十六进制数
`\d\+'d[0-9_]\+` 十进制数
`\d\+'b[01_]\+` 二进制数

那么匹配任意数字的正则表达式就是将上面几个部分用`\|`连接起来写作

`\d\+\|\d\+'h[0-9a-fA-F_]\+\|\d\+'d[0-9_]\+\|\d\+'b[01_]\+`

匹配localparam的正则表达式就写作

`localparam\s\+[a-zA-Z_]\w*\s*=\s*\(\d\+\|\d\+'h[0-9a-fA-F_]\+\|\d\+'d[0-9_]\+\|\d\+'b[01_]\+\);`

由此可见写正则表达式越准确, 正则表达式就会越复杂, 大部分情况下用不到精确的正则表达式, 所以可以根据代码的实际情况简化正则表达式, 给自己节省一点时间
例如把上面的parameter的名字部分从`[a-zA-Z_]\w*`改成`\w\+`
再比如我的需求只是找到`localparam`然后把等号对齐，那么等号后面的部分我就不需要关心，甚至不是数字也对我没有影响，那么就可以把这个表达式写成`localparam\s\+\w\+\s*=.*`

### 2.4 零宽字符

零宽字符表示一个匹配的锚点, 和元字符不同的是, 零宽字符不占用任何一个字符, 宽度为0

常用的零宽字符有

- `^` 一行的开头
- `$` 一行的结尾
- `\<` 单词的开头
- `\>` 单词的结尾

>例如：
>`^\s*$`     匹配空行
>`^\s*\/\/`  匹配C风格行注释
>`\s*$`      匹配行尾空格
>`\<rvalid`  匹配一个rvalid开头的名字, 忽略arvalid之类的名字
>`_oe\>`     匹配一个_oe结尾的名字, 忽略_oen之类的名字
>`\<clk\>`   匹配clk, 忽略aclk, pclk, clken之类的名字

#### 2.4.1 例子：verilog的连续赋值语句

`^\s*assign\s\+\w\+\s*=\s*.*;\s*$`

### 2.5 转义字符

由于., *, /, ^, $等字符已经被正则表达式赋予了特殊含义, 如果要匹配这些字符, 就需要在字符前加一个`\`
例如匹配一个verilog文件的名字, `\w\+\.v`
匹配一个perl中的变量名, `\$\w\+`

或者把他们用中括号括起来, 因为中括号优先级最高, 例如verilog文件名也可以用`\w\+[.]v`
可以按照自己的习惯选择反斜线或者中括号, 中括号的好处是表达式里不会出现大量反斜线, 造成阅读困难

### 2.6 总结

| 语法   | 重要性 | 说明 |
| ----   | ------ | ---- |
| `.`    | 重要 | 表示任一字符
| `\w`   | 非常重要 | 表示字母或数字或下划线(word)
| `\d`   | 重要 | 表示数字0到9(digit), 有些工具不支持\d, 比如sed, 这时要用[0-9]替代
| `\s`   | 非常重要 | 表示空格或tab(space)
| `\W`   | 一般 | 表示不是`\w`
| `\D`   | 一般 | 表示不是数字
| `\S`   | 重要 | 表示不是空格
| `[]`   | 重要 | 中括号表示元字符的选择
| `-`    | 重要 | 中括号中的连字符表示元字符的选择范围
| `^`    | 一般 | 中括号开头的尖号表示取反
| `*`    | 非常重要 | 表示0到多个
| `\+`   | 非常重要 | 表示1到多个
| `\?`   | 重要 | 表示0个或1个
| `\(\)` | 非常重要 | 将一串元字符或者量词包起来作为一个整体
| `\|`   | 非常重要 | 正则表达式的或操作, 表示选择其中之一
| `^`    | 非常重要 | 一行的开头
| `$`    | 非常重要 | 一行的结尾
| `\<`   | 重要 | 单词的开头
| `\>`   | 重要 | 单词的结尾

> perl风格的正则表达式语法里, `\+`, `\?`, `\(\)`, `\|`不带`\`, `\<`, `\>`写作`\b`

正则表达式的语法非常丰富, 这里提到的只是凤毛麟角, 但是已经可以解决工作中遇到的常见问题了

vim的文档里有完整的语法说明, 在vim中执行下面的命令可以做查询

- `:help pattern-searches`
  - 正则表达式帮助文件的开头
- `:help /character-classes`
  - 字符类型, 比如`\s`, `\w`
- `:help pattern-multi-items`
  - 量词
- `:help pattern-atoms`或`:help /zero-width`
  - 零宽字符
- `:help /\s`
  - 查询`\s`的用法, `\s`前面的斜线表示这是一个正则表达式相关的帮助信息

## 3 vim中的命令

vim中有几个常用命令可以用正则表达式
`/`, `?` 搜索
`:g`, 批量执行
`:s`, 搜索替换

这三个命令都是来自于ed编辑器, 所以sed也支持`/`, `g`, `s`命令, 两者的语法是兼容的

### 3.1 `/`的使用

平时在vim里常用的`/`搜索其实就是正则表达式, 而vim并不支持通配符搜索
有些人在用`/reg_*`去搜索`reg_intr_status`之类的信号名时会找不到, 觉得不符合自己预期
但vim其实找的是`reg_`, `reg__`, `reg___`之类的名字
正确的写法是`/reg_\w\+`

其他相关快捷键

- `?`快捷键是反向搜索，和`/`的含义正好相反
- `*`快捷键与`gd`快捷键可以按照完整的单词去搜索信号名
  - `*`等价于`/\<当前光标下的单词\>`
- `gd`快捷键跳转到当前光标下的单词第一次出现的地方, 也就是变量的声明位置

### 3.2 `g`的使用

`g`表示搜索并执行操作, 一般的用法是`:range g/pattern/edcmd`

- `range`表示一个范围, 例如
  - 如果不写range, 则表示范围是整个文件
  - 1, 4表示第1行到第4行
  - %表示整个文件
  - '<, '>表示刚才选中的区域, 一般的做法是用V或者v, Ctrl-v选中一块区域, 选中之后按冒号, 会自动将'<, '>添加到vim界面下面的命令窗口
- `/pattern/`表示一个正则表达式
- `edcmd`和sed命令兼容, 这里不展开, 只介绍两个edcmd
  - `d`, 删除
  - `m`, 移动

例如
`:g/^\s*$/d`表示删除空行
`:g/^\s*\/\/$/d`表示删除注释行
`:20, 40g/^\s*input/d`表示删除20到40行之间所有用input开头的行
`:g/^\s*Error/m7`表示把Error开头的行全部移动到第7行下面
`:g/^\s*Error/m0`表示把Error开头的行全部移动到文件开头
`:g/^\s*Error/m$`表示把Error开头的行全部移动到文件末尾

> grep命令的全称是`g/re/p`, re表示regular expression, p表示print命令, 也就是搜索正则表达式并打印出来的意思

### 3.3 `s`的使用

`s`命令表示替换, 其本质上是一个edcmd
完整的命令形式为`:range g/pattern1/ s/pattern2/replace/`
表示在range范围中搜索pattern1, 然后将这些行中的pattern2换成replace
由于大部分情况下, pattern1和pattern2都是同一个, 所以这条命令往往写成

```vim
:range s/pattern/replace/
```

其中的pattern就是正则表达式, replace是一个字符串, 用来替代搜索到的内容

s命令是使用最频繁的命令之一

上面对正则表达式的所有铺垫几乎都是服务于s命令的, 用好s命令的话, 不论vim还是sed里都可以提高改代码的效率

s命令中使用最频繁的正则表达式语法是分组操作`\(\)`, 这个操作被括起来的部分可以在后面的replace部分调用
按照pattern中`\(`**左括号出现的顺序**, 括号中被匹配到的内容分别用`\1`, `\2`, `\3`表示

例如有两组apb信号被命名为

```verilog
    wire        pclk_abc;
    wire        presetn_abc;
    wire        psel_abc;
    wire        pwrite_abc;
    ...
    wire        pclk_def;
    wire        presetn_def;
    wire        psel_def;
    wire        pwrite_def;
    ...
```

需要将这部分内容修改为

```verilog
    wire        abc_pclk;
    wire        abc_presetn;
    wire        abc_psel;
    wire        abc_pwrite;
    ...
    wire        def_pclk;
    wire        def_presetn;
    wire        def_psel;
    wire        def_pwrite;
    ...
```

只需要先选中这块代码, 然后输入`:`, vim的命令行会出现`:'<, '>`
然后输入`s/\(\w\+\)_\(\w\+\)/\2_\1/`回车即可

对于稍微复杂点的情况, 就需要在pattern的正则表达式增加更多的内容, 让vim更加精准得匹配到自己想要的部分, 然后再做替换

## 4 补充资料

正则表达式的语法细节非常多, 而且需要大量实践, 所以建议把常用的掌握了再根据自己需求去学习更多的, 下面几个是比较好的可以查询的资料, linux里就有

vim内置文档：
    `:help pattern-searches`

perl文档：
    `$ man perlre`
    `$ man perlretut`
    `$ man perlrequick`

另外有一本已经停印的书也可以找一找作为参考
`《精通正则表达式》, 作者：Jeffery Friedl`
