#!/usr/bin/env python3
import os
import re
import argparse

parser = argparse.ArgumentParser(description="Generate Blackbox Files")
parser.add_argument(dest="filename", metavar="block.v")
parser.add_argument('-v', '--verbose',  dest="verbose", action="store_true",    help="Verbose mode")
parser.add_argument('-l', '--lint',     dest="lint",    action="store_true",    help="render lint related logic")
parser.add_argument('-b', '--blackbox', dest="blackbox", action="store_true",   help="render port only")
parser.add_argument('-t', '--tieoff',   dest="tieoff",  action="store_true",    help="render tieoff logic only")
parser.add_argument('-o', '--output',   dest="ofile",   action="store",         help="output file")
parser.add_argument('-P', '--postfix',  dest="postfix", action="store",         help="postfix")
args = parser.parse_args()

if args.filename == args.ofile:
    raise SystemExit("ERROR: It is not allowed to use the same file as input and output too")

(modname, modext) = os.path.splitext(os.path.basename(args.filename))
dirname = os.path.dirname(args.filename)
if args.ofile is None:
    if args.tieoff and not args.blackbox:
        midfix = ".tieoff"
    else:
        midfix = ".bb"
    if args.postfix is None:
        args.ofile = os.path.join(dirname, f"{modname}{midfix}{modext}")
    else:
        args.ofile = os.path.join(dirname, f"{modname}{midfix}{args.postfix}")


PARAMS = {}

PORT_DECL_PATTERN  = re.compile(r'\s*,?\s*(input|output|inout)\s*(wire|logic|reg)?\s*(\[(.*?):(.*?)\])?\s*(\w+)\s*(\[(.*?):(.*?)\])?\s*[,;]?\s*')
PARAM_DECL_PATTERN = re.compile(r'(localparam|parameter).*?\s+(\w+)\s*=\s*((((\d+)?(\'[hdb])?[0-9a-fA-F_]+)|[+*()\-]|\s+|\w+)+)$')
VLOG_NUM_PATTERN   = re.compile(r'(\d*)\'([hdb])([0-9a-fA-F_]+)')


def open_del_comment(fl):
    fl_tmp = open(fl,'rb').read()
    rtllist = []
    for x in fl_tmp:
        if 0x20 <= x <= 0x7E:
            rtllist.append(x)
        elif x == 0x09 or x == 0x0a or x == 0x0d:
            rtllist.append(x)
        else:
            rtllist.append(0x20)
    strtemp = bytes(rtllist).decode('ascii')
    strdc = re.sub(r'''(?P<blankline>^\s*\n) |
                   (?P<onelinecomments>^//.*?\n) |
                   (?P<linecomments>/\*(.|\r\n)*?\*/) ''', '', strtemp, 0, re.DOTALL|re.VERBOSE|re.MULTILINE)
    return strdc

def get_port_list(src_file):
    post_list = []
    strpure = open_del_comment(src_file).split('\n')
    for line in strpure:
        line = line.strip().split('//')[0]
        if re.match(r'endmodule', line):
            break
        else:
            sentences = [x.strip() for x in re.split(r',|;', line)]
            for s in sentences:
                if re.match(r'\b(input|output|inout)\b', s):
                    port_list.append(s)
    return port_list


def vlognumrepl(m):
    if m.group(2) == "h":
        return str(int(m.group(3), 16))
    elif m.group(2) == "b":
        return str(int(m.group(3), 2))
    elif m.group(2) == "d":
        return str(int(m.group(3), 10))
    raise ValueError(f"m.group(0) is not a valid verilog number")

def get_params(src_file):
    strpure = open_del_comment(src_file).split("\n")
    for line in strpure:
        line = line.strip().split('//')[0]
        sentences = [x.strip() for x in re.split(r',|;', line)]
        for s in sentences:
            m = re.match(PARAM_DECL_PATTERN, s)
            if m is not None:
                k = m.group(2)
                cmd = re.sub(VLOG_NUM_PATTERN, vlognumrepl, m.group(3))
                v = eval(cmd, PARAMS)
                PARAMS[k] = v


def print_port(port_list):
    outfid = open(args.ofile, 'a')
    outfid.write('module ' + modname + '\n')
    outfid.write('(' + '\n')
    len_list = len(port_list)
    i = 0

    for line in port_list:
        i = i + 1

        m = re.fullmatch(PORT_DECL_PATTERN, line)
        if m is None:
            raise ValueError(f'Unrecognized port declaration on line {i}: {line}')
        
        port_direct = m.group(1)
        port_type = m.group(2) if m.group(2) is not None else "wire"
        if m.group(3) is None:
            port_width = ''
        else:
            port_width = '[' + str(int(eval(m.group(4), PARAMS))) + ':' + str(int(eval(m.group(5), PARAMS))) + ']'
        port_name = m.group(6)
        if m.group(7) is None:
            port_array = ''
        else
            port_array = '[' + str(int(eval(m.group(8), PARAMS))) + ':' + str(int(eval(m.group(9), PARAMS))) + ']'
        port_comma = "," if i < len_list else ""

        outfid.write(f"    {port_direct:<6}  {port_type:<5}   {port_width:<12} {port_name}{port_array}{port_comma}\n")
    outfid.write(');\n')
    outfid.close()

def print_output_assign(port_list):
    outfid = open(args.ofile, "a")

    for line in port_list:
        if "output" in line:
            m = re.fullmatch(PORT_DECL_PATTERN, line)
            if m is None:
                raise ValueError(f'Unrecognized port declaration on line {i}: {line}')

            if m.group(3) is None:
                port_width = 1
            else:
                port_width = int(eval(m.group(4), PARAMS)) - int(eval(m.group(5), PARAMS)) + 1
            port_name = m.group(6)
            if m.group(7) is None:
                port_array = 1
            else:
                port_array = int(eval(m.group(8), PARAMS)) - int(eval(m.group(9), PARAMS)) + 1
            if port_array == 1:
                outfid.write(f"    assign  {port_name:<40}= {port_width}'h0;\n")
            else:
                outfid.write(f"    assign  {port_name:<40}= " + "{" + f"{port_array}" + "{" + f"{port_width}'h0}};\n")
        else:
            pass

    outfid.close()


def print_input_unused(src_file):
    if not args.lint:
        return
    
    strpure = open_del_comment(src_file).split('\n')
    unused_inputs = []
    for line in strpure:
        line = line.strip().split('//')[0]
        if line.startswith('//'):
            pass
        elif re.match("input", line):
            unused_inputs.append(line.split(',|;')[0])

    outfid = open(args.ofile, 'a')

    total_width = 0
    unused_signals = []
    for line in unused_inputs:
        line = line.replace("wire", "").replace("logic", "").replace("reg", "").replace(",","")
        if "input" in line:
            if "]" in line:
                name = line.replace(" ", "").split(']')[1]
                msb = line.replace(" ", "").split('[')[1].split(":")[0]
                lsb = line.replace(" ", "").split(':')[1].split("]")[0]
                width = int(eval(msb, PARAMS) - eval(lsb, PARAMS) + 1)
                total_width += width
                unused_signals.append(name.strip())
            else:
                name = line.replace(" ", "").split("put")[1]
                total_width += 1
                unused_signals.append(name.strip())
        else:
            pass

    indent = len("assign unused = {   ") * " "
    unused = f',\n{indent}'.join(unused_signals)
    outfid.write(f'\n')
    outfid.write(f'//spyglass disable_block W528\n')
    outfid.write(f'wire [{total_width-1}:0] unused;\n')
    outfid.write(f'assign unused = {{\n{indent}{unused}\n}};\n')
    outfid.write(f'//spyglass enable_block W528\n')

def print_port_post(src_file):
    outfid = open(args.ofile, 'a')
    strpure = open_del_comment(src_file).split('\n')
    for line in strpure:
        line = line.strip()
        line = re.sub(r'//.*$', '', line)
        if re.search(r"(input|output|inout|parameter|localparam).*;", line):
            outfid.write(line + '\n')

def print_end_module():
    outfid = open(args.ofile, 'a')
    outfid.write('\nendmodule\n')
    outfid.close()

def print_tieoff_guard_begin():
    with open(args.ofile, 'a') as f:
        f.write(f'`ifdef {modname.upper()}_TIEOFF\n')

def print_tieoff_guard_end():
    with open(args.ofile, 'a') as f:
        f.write(f'`endif // {modname.upper()}_TIEOFF\n')

if __name__ == "__main__":
    port_list = get_port_list(args.filename)
    get_params(args.filename)

    os.system("rm -f " + args.ofile)
    if args.tieoff and args.blackbox:
        print_port(port_list)
        print_output_assign(port_list)
        print_port(port_list)
